### What is SKU?
SKU stands for Stock Keeping Unit ‚Äî it‚Äôs Microsoft‚Äôs way of saying the pricing tier or edition of a resource.
In Azure, almost every resource type (VMs, Storage Accounts, App Service Plans, Databases, etc.) has different SKUs that determine:
Performance level (e.g., how powerful a VM is, how fast storage is)
Features available (e.g., redundancy, geo-replication)
Cost (higher SKUs usually cost more)

| Feature           | AD DS                                    | Microsoft Entra ID                   |
| ----------------- | ---------------------------------------- | ------------------------------------ |
| Object types      | Users, Groups, Computers, Printers, etc. | Users, Groups, Devices, Applications |
| Computer class    | ‚úÖ Yes                                    | ‚ùå No                                 |
| Device management | Domain-joined                            | Device-registered / Azure AD joined  |
| Extensibility     | Possible but complex                     | Easy, reversible                     |
| Schema updates    | Controlled, more static                  | Cloud-managed, flexible              |

Device Writeback is a feature in Microsoft Entra Connect that allows devices registered in Microsoft Entra ID (cloud) to be written back into your on-premises Active Directory (AD DS).

| **Error / Topic**                                                           | **What It Means**                                                                 | **Why It Happens**                                                                             | **How to Fix / Action**                                                                                       |
| --------------------------------------------------------------------------- | --------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------- |
| **1Ô∏è‚É£ Not enough licenses ‚Äî `CountViolation`**                              | The group or user needs a license, but there aren‚Äôt enough available.             | All available licenses for that SKU are already assigned.                                      | Purchase more licenses or unassign unused ones. Then reprocess the group/user.                                |
| **2Ô∏è‚É£ Service plans that conflict ‚Äî `MutuallyExclusiveViolation`**          | Two service plans can‚Äôt coexist under the same user.                              | Some products have overlapping or mutually exclusive plans (e.g., two different M365 bundles). | Review service plans, remove conflicting ones, and reassign.                                                  |
| **3Ô∏è‚É£ Other products depend on this license ‚Äî `DependencyViolation`**       | A dependent license is being removed, breaking another product‚Äôs functionality.   | Removing one plan disables a required dependency (e.g., Exchange needed by Teams).             | Keep the required base plan active or disable dependent features first.                                       |
| **4Ô∏è‚É£ Usage location isn‚Äôt allowed ‚Äî `ProhibitedInUsageLocationViolation`** | The assigned license isn‚Äôt available in the user‚Äôs country.                       | Some services aren‚Äôt offered in certain regions.                                               | Update the user‚Äôs **Usage Location** attribute to a supported country before assigning.                       |
| **5Ô∏è‚É£ Duplicate proxy addresses**                                           | Two users have the same **email alias (proxyAddress)**.                           | Duplicate mail aliases conflict with Exchange Online or mail-enabled groups.                   | Correct duplicates in **ProxyAddresses** via Entra or Exchange Admin Center. Then force license reprocessing. |
| **6Ô∏è‚É£ Microsoft Entra Mail and ProxyAddresses attribute change**            | Assigning or updating licenses triggers recalculation of mail-related attributes. | License updates cause Entra ID to recalculate attributes like `mail` or `proxyAddresses`.      | Normal behavior. Monitor for unintended address overwrites if sync is involved.                               |
| **7Ô∏è‚É£ `LicenseAssignmentAttributeConcurrencyException` in audit logs**      | User received duplicate license assignment requests concurrently.                 | The user belongs to multiple licensed groups with the same license SKU.                        | No manual action needed. Entra ID retries automatically and resolves it.                                      |
| **8Ô∏è‚É£ More than one product license assigned to a group**                   | The same group has multiple overlapping licenses.                                 | Admin assigned multiple SKUs with overlapping services to one group.                           | Simplify ‚Äî assign only one product license per group for clarity.                                             |
| **9Ô∏è‚É£ When a licensed group is deleted**                                    | Users lose licenses inherited from that group.                                    | Deletion removes license inheritance.                                                          | Ensure licenses are reassigned via another group or individually before deleting the licensed group.          |
| **üîü Manage licenses for products with prerequisites**                      | Some services depend on other base services.                                      | Example: Intune requires Azure AD Premium.                                                     | Assign prerequisite licenses before assigning dependent ones.                                                 |
| **1Ô∏è‚É£1Ô∏è‚É£ Force the group license process to resolve errors**                | Re-triggers license evaluation for a group.                                       | Useful when issues like CountViolation or Proxy errors occur.                                  | Go to **Group > Licenses > Reprocess** in Entra ID.                                                           |
| **1Ô∏è‚É£2Ô∏è‚É£ Force the user license process to resolve errors**                 | Re-triggers license assignment for a user.                                        | Fixes temporary sync or dependency issues.                                                     | Go to **User > Licenses > Reprocess**.                                                                        |
| **1Ô∏è‚É£3Ô∏è‚É£ Migrate users with individual licenses to group licenses**         | Moves manually assigned licenses to group-based assignment.                       | For centralized license control.                                                               | Remove individual licenses, add user to appropriate licensed group. Ensure group has all required services.   |
| **1Ô∏è‚É£4Ô∏è‚É£ Change license assignments for a user or group**                   | Modify what products or service plans a user/group gets.                          | Needed when upgrading/downgrading plans.                                                       | Use **Microsoft Entra admin center ‚Üí Licenses ‚Üí Assignments** or PowerShell commands.                         |



| Term                      | Description                                                                                                  |
| ------------------------- | ------------------------------------------------------------------------------------------------------------ |
| **Policy Definition**     | A rule that enforces or audits a specific condition (e.g., ‚ÄúVMs must use managed disks‚Äù).                    |
| **Initiative Definition** | A collection (bundle) of multiple policies designed to meet a goal (e.g., ‚ÄúEnable ISO 27001 compliance‚Äù).    |
| **Assignment**            | The process of applying a policy or initiative to a scope (management group, subscription, resource group).  |
| **Scope**                 | Where the policy applies ‚Äî can be at management group, subscription, or resource group level.                |
| **Parameters**            | Variables used in policies/initiatives so you can customize behavior (e.g., specify a location or tag name). |


‚öôÔ∏è 1. Control Plane

What it is:
The control plane is the management layer of Azure.
It‚Äôs where you create, configure, and delete Azure resources.
Operations here go through Azure Resource Manager (ARM).

Examples:
Creating a new Azure Storage account.
Updating a VM‚Äôs size or tags.
Assigning a role to a user (RBAC).
Setting up a network security group (NSG).

APIs involved:
management.azure.com (via ARM)

Security:
Controlled by Azure RBAC and management permissions at the resource/subscription level.

üì¶ 2. Data Plane

What it is:
The data plane lets you interact directly with the resource once it‚Äôs created ‚Äî to use or retrieve data from it.

Examples:
Uploading or downloading blobs from an Azure Storage account.
Querying a database in Azure SQL.
Accessing a Key Vault secret.
Reading messages from an Event Hub.

APIs involved:
Resource-specific endpoints like *.blob.core.windows.net, *.database.windows.net, etc.

Security:
Controlled by resource-level access, such as:

Shared keys
SAS tokens
Azure AD authentication
Managed identities

‚öôÔ∏è Azure Policy Operation Scenarios
üå± 1. Greenfield (Policy-First Scenario)
üí° Meaning:
You already have Azure Policy defined and active before resources are created or modified.
When a user tries to create or update a resource, the policy immediately evaluates the request.

üß© How it works:
A user (or system) sends a request to create or update a resource via Azure Resource Manager (ARM).
ARM processes the request through several layers:
RBAC (Role-Based Access Control) ‚Äî checks if the user has the right permissions.
Azure Policy ‚Äî checks if the resource complies with the defined policies.
If the user lacks permission ‚Üí request fails at RBAC stage.
If the user passes RBAC ‚Üí Azure Policy evaluates the request.
For updates, Azure Policy needs the full resource state, so it merges:
The current state (existing configuration),
With the requested changes (delta),
And evaluates the target state against the policies.

‚úÖ Example:
A policy restricts resources to West Europe.
When a user tries to create a resource in East US, the policy blocks it immediately.

‚öôÔ∏è Use Case:
Policy-first environments
Preventive control ‚Äî stops noncompliant resources from being created

üèóÔ∏è 2. Brownfield (Resource-First Scenario)
üí° Meaning:
You already have existing resources, and you apply a new Azure Policy later.
The policy doesn‚Äôt block anything initially ‚Äî it evaluates compliance afterward.

üß© How it works:
The policy is assigned after resources already exist.
Azure Policy runs a compliance scan:
Automatically every 24 hours, or
Manually triggered by an administrator.
The scan reads all existing resources within the policy‚Äôs scope.
It then updates the compliance state (Compliant / Noncompliant) for each resource.

‚úÖ Example:

A new policy requires all resources to be in West Europe.
Existing East US resources aren‚Äôt deleted.
They‚Äôre marked as noncompliant.
Future creations in East US will fail due to the policy.

‚öôÔ∏è Use Case:
Resource-first environments
Detective control ‚Äî identifies but doesn‚Äôt block existing noncompliant resources

| Feature                          | **Greenfield (Policy-First)**             | **Brownfield (Resource-First)**                 |
| -------------------------------- | ----------------------------------------- | ----------------------------------------------- |
| **When policy is applied**       | Before resource creation                  | After resources already exist                   |
| **Evaluation trigger**           | On each create/update request             | Compliance scan (24h / manual)                  |
| **Enforcement type**             | Preventive (denies noncompliant requests) | Detective (flags noncompliant resources)        |
| **Effect on existing resources** | Evaluated immediately                     | Marked noncompliant after scan                  |
| **Typical use case**             | Governance during provisioning            | Assessing and remediating existing environments |

| Concept              | Purpose                                                          | Example                                   |
| -------------------- | ---------------------------------------------------------------- | ----------------------------------------- |
| **Enforcement Mode** | Controls whether a policy actively blocks/deploys or just audits | `DoNotEnforce` for testing                |
| **Managed Identity** | Grants permissions for automatic deployment or modification      | Used with `DeployIfNotExists` or `Modify` |
| **System-assigned**  | Identity created automatically for the assignment                | Self-contained                            |
| **User-assigned**    | Reusable identity shared across policies                         | Centralized management                    |

‚öôÔ∏è 1. What Is a Policy Exemption?
A policy exemption is a resource in Azure that tells Azure Policy to ignore a specific policy or initiative for certain resources.
It behaves similarly to an excluded scope, but you define it after the policy has been assigned.

üìå Key difference:
Excluded scope = defined during assignment.
Exemption = defined after assignment, as a separate child resource under the policy or resource hierarchy.

| Exclusion                            | Exemption                                           |
| ------------------------------------ | --------------------------------------------------- |
| Defined **during** policy assignment | Created **after** assignment                        |
| Applies to all future evaluations    | Can be applied to existing resources selectively    |
| Managed by policy admins             | Can be granted by resource owners (with permission) |
| No expiration support                | Supports expiration and categorization              |

| Concept           | Description                                                              |
| ----------------- | ------------------------------------------------------------------------ |
| **Purpose**       | Temporarily or permanently exclude a resource from policy enforcement    |
| **Created when?** | After policy assignment                                                  |
| **Where stored?** | As a child resource under the policy hierarchy                           |
| **Categories**    | Mitigated (policy intent met otherwise), Waiver (noncompliance accepted) |
| **Effect**        | Resource ignored in compliance scans                                     |
| **Extras**        | Can include expiration, justification, and category metadata             |

‚úÖ Attestations in Azure Policy (Simplified Explanation):
Attestations are manual confirmations of compliance used within Azure Policy. They help when compliance cannot be automatically verified by Azure (for example, checking if a document or process exists).

Here‚Äôs how they work:
When a manual policy is assigned to a scope (like a subscription or resource group), each resource under that scope needs an attestation.
The attestation confirms that the resource meets the policy‚Äôs intent ‚Äî even if Azure can‚Äôt check it automatically.
Once an attestation is submitted, it updates the compliance state of that resource to Compliant.
One attestation is required per manual policy assignment per resource.

üí° Example:
Suppose there‚Äôs a policy requiring ‚ÄúSecurity review documentation for all VMs.‚Äù
Azure can‚Äôt automatically check that, so you create a manual policy.
Then, for each VM, you submit an attestation confirming the review has been done.

In short ‚Äî attestations = manual compliance proof for resources under manual policy assignments.

‚úÖ Remediations in Azure Policy (Simplified Explanation):
Remediation tasks are used to fix noncompliant resources automatically so they meet the policy requirements.

Here‚Äôs how they work:
When you assign a policy with deployIfNotExists or modify effect, Azure Policy can automatically correct resources that don‚Äôt comply.
If existing resources are already noncompliant, you can create a remediation task to bring them into compliance.
Any newly created or updated resources that fall under that policy scope are automatically remediated (fixed) during deployment.

üí° Example:
If a policy says ‚ÄúAll storage accounts must have encryption enabled‚Äù ‚Äî
and some storage accounts don‚Äôt ‚Äî
a remediation task can automatically enable encryption on those noncompliant storage accounts.

üîß Key points:
Works only with modify or deployIfNotExists effects.
Can be triggered manually (via remediation task) or automatically for new resources.
Often uses a managed identity to perform changes on the resources.

Managed identity = Azure-managed service account.
Two types: System-assigned and User-assigned.
Used for secure authentication without credentials.
Works for VMs, Functions, Policies, App Services, and more.
Essential for remediation tasks, automated access, and cross-service communication.

| Feature   | System-assigned             | User-assigned                      |
| --------- | --------------------------- | ---------------------------------- |
| Scope     | Single resource only        | Multiple resources                 |
| Lifecycle | Tied to resource            | Independent                        |
| Creation  | Automatically with resource | Manually created first             |
| Deletion  | Deleted with resource       | Stays alive until manually deleted |
| Use case  | Simple, one-off access      | Shared access across resources     |

Azure Policy Definition - Conditions

| Concept       | Meaning                          | Example                                        |
| ------------- | -------------------------------- | ---------------------------------------------- |
| **count()**   | How many items are in an array   | ‚ÄúHow many tags does this resource have?‚Äù       |
| **where**     | Filter array items by condition  | ‚ÄúWhich rules have access=Allow?‚Äù               |
| **current()** | Refers to the item being checked | ‚ÄúCheck if the current tag key = ‚Äòenvironment‚Äô‚Äù |

Policy Functions
ipRangeContains(range, targetRange) 	
‚óè range: [Required] string - String specifying a range of IP addresses to check if the targetRange is within range.
‚óè targetRange: [Required] string - String specifying a range of IP addresses to validate as included within the range.
Returns a boolean for whether the range IP address range contains the targetRange IP address range. Empty ranges or mixing between IP families isn't allowed and results in evaluation failure.

current(indexName) 	Special function that can only be used inside count expressions.

Effect types (then blocks):

| Effect                | Purpose                                              | Interchangeable With                         | Notes                                                                      |
| --------------------- | ---------------------------------------------------- | -------------------------------------------- | -------------------------------------------------------------------------- |
| **audit**             | Logs noncompliance, does not block actions           | deny, modify, append (depending on scenario) | Useful for testing policies before enforcement                             |
| **deny**              | Prevents creation/update of noncompliant resources   | audit, modify, append                        | Blocks noncompliant resources                                              |
| **modify**            | Automatically fixes noncompliant resources           | audit, deny, append                          | Can update existing resources to comply                                    |
| **append**            | Adds properties to make resources compliant          | audit, deny, modify                          | Can append tags or settings to resources                                   |
| **auditIfNotExists**  | Checks if dependent resource exists, logs if missing | deployIfNotExists                            | Often interchangeable with deployIfNotExists for dependent resource checks |
| **deployIfNotExists** | Deploys dependent resource automatically             | auditIfNotExists                             | Automatically fixes missing dependent resources                            |
| **manual**            | Requires human intervention to mark compliance       | ‚ùå None                                       | Cannot be auto-remediated, used for policies needing manual approval       |
| **disabled**          | Temporarily turns off policy enforcement             | Any effect                                   | Useful for testing or temporarily suspending compliance checks             |


Azure RBAC is an allow model. This means that when you're assigned a role, Azure RBAC allows you to perform certain actions such as read, write, or delete. 
Azure RBAC has something called NotActions permissions. You can use NotActions to create a set of not allowed permissions. 
The access a role grants‚Äîthe effective permissions‚Äîis computed by subtracting the NotActions operations from the Actions operations.

###Storage Replication Strategies

| Replication Type | Full Name                              | Where Are the Copies Kept?                                                 | Protection Level                                           | Use Case                                               |
| ---------------- | -------------------------------------- | -------------------------------------------------------------------------- | ---------------------------------------------------------- | ------------------------------------------------------ |
| **LRS**          | Locally Redundant Storage              | 3 copies **in one datacenter**                                             | ‚úÖ Protects against hardware failure inside that datacenter | Cheapest option; for non-critical data                 |
| **ZRS**          | Zone-Redundant Storage                 | 3 copies **across 3 zones (availability zone)** in one region                                  | ‚úÖ Protects against datacenter failure                      | Good for high availability inside one region           |
| **GRS**          | Geo-Redundant Storage                  | 3 copies in **primary region**(LRS)+ 3 copies in **secondary (paired) region(LRS)** | ‚úÖ Protects against regional outage                         | For disaster recovery; read access only after failover |
| **RA-GRS**       | Read-Access Geo-Redundant Storage      | Same as GRS, but you can **read from secondary region anytime**            | ‚úÖ‚úÖ Read access even during outage                          | For apps that need constant read availability          |
| **GZRS**         | Geo-Zone-Redundant Storage             | 3 copies across **zones(AZ)** in primary + 3 in **secondary region(LRS)**           | ‚úÖ Combines ZRS + GRS                                       | Very high durability and availability                  |
| **RA-GZRS**      | Read-Access Geo-Zone-Redundant Storage | GZRS + **read from secondary**                                             | ‚úÖ‚úÖ Best protection + read access                           | Mission-critical apps                                  |

Let's look at an example. If your storage account name is mystorageaccount, 
We create the URL to access an object in your storage account by appending the object's location in the storage account to the endpoint.
For example, to access the myblob data in the mycontainer location in your storage account, we use the following URL address:
//mystorageaccount.blob.core.windows.net/mycontainer/myblob. ->storageaccountname + domain name + location + object

| Storage Type           | Backed By                    | Use Case                               | Analogy                         |
| ---------------------- | ---------------------------- | -------------------------------------- | ------------------------------- |
| **Data Lake Storage**  | HDD/SSD (big data optimized) | Store massive raw data for analytics   | Giant ocean of data             |
| **Premium Block Blob** | SSD                          | Fast access to files (videos, backups) | Fast shelf of digital files     |
| **Premium File Share** | SSD                          | Network drive with fast shared access  | Office shared drive             |
| **Premium Page Blob**  | SSD                          | VM disks and databases                 | Hard drive for virtual machines |


###Blob Storage
Azure Blob Storage uses a container resource to group a set of blobs. A blob can't exist by itself in Blob Storage. A blob must be stored in a container resource.
explanation:storage account->blob containers->blob objects

All blobs must be in a container.
Containers organize your blob storage.
A container can store an unlimited number of blobs.
An Azure storage account can contain an unlimited number of containers.
You must create a storage container before you can begin to upload data.

| Level               | Example            | Must Be Unique                | Reason                                       |
| ------------------- | ------------------ | ----------------------------- | -------------------------------------------- |
| **Storage Account** | `mystorageaccount` | üåç **Globally**               | Used in public URL (`blob.core.windows.net`) |
| **Container**       | `images`           | üè† **Within storage account** | Each account has its own namespace           |
| **Blob (File)**     | `photo.jpg`        | üìÅ **Within container**       | Prevents filename clash in same folder       |

Archive tier = cheapest storage for rarely used data.
You can‚Äôt open it directly ‚Äî you must rehydrate (move) it to Hot/Cool/Cold to use it again.
Metadata (like file name, tags) stays visible even while it‚Äôs archived.

| Feature / Tier               | **Hot**                                     | **Cool**                    | **Cold**                    | **Archive**                                              |
| ---------------------------- | ------------------------------------------- | --------------------------- | --------------------------- | -------------------------------------------------------- |
| **Purpose**                  | Frequently accessed data                    | Infrequently accessed data  | Rarely accessed data        | Long-term backup or compliance data                      |
| **Data availability**        | Immediate                                   | Immediate                   | Immediate                   | ‚ùå Not direct (rehydration needed)                        |
| **Typical latency**          | Milliseconds                                | Milliseconds                | Milliseconds                | Hours (rehydration required)                             |
| **Rehydration time**         | N/A                                         | N/A                         | N/A                         | ‚è±Ô∏è 1‚Äì15 hours (Standard) <br> ‚è±Ô∏è ~1 hour (High priority) |
| **Read cost**                | üí∏ Low                                      | üí∞ Higher                   | üí∞ Higher                   | üßä Highest (after rehydration)                           |
| **Write cost**               | üí∞ Higher                                   | üí∏ Lower                    | üí∏ Lower                    | üí∏ Lowest                                                |
| **Storage cost**             | üí∞ Highest                                  | üí∏ Lower                    | üí∏ Even lower               | üßä Lowest                                                |
| **Data redundancy options**  | LRS, ZRS, GRS, RA-GRS                       | LRS, ZRS, GRS, RA-GRS       | LRS, ZRS, GRS, RA-GRS       | LRS, GRS, RA-GRS (no ZRS)                                |
| **Minimum storage duration** | None                                        | 30 days                     | 90 days                     | 180 days                                                 |
| **Use cases**                | Active apps, websites, streaming, analytics | Backup, short-term archives | Long-term infrequent access | Legal retention, compliance, long-term cold archive      |
| **Direct read/write**        | ‚úÖ Yes                                       | ‚úÖ Yes                       | ‚úÖ Yes                       | ‚ùå No (rehydrate first)                                   |
| **Metadata availability**    | ‚úÖ Yes                                       | ‚úÖ Yes                       | ‚úÖ Yes                       | ‚úÖ Yes (even while archived)                              |
| **Data modification**        | ‚úÖ Allowed                                   | ‚úÖ Allowed                   | ‚úÖ Allowed                   | ‚ùå Not allowed (until rehydrated)                         |


##Blob Object Replication


| Feature / Rule                | Explanation                                                                      |
| ----------------------------- | -------------------------------------------------------------------------------- |
| **Blob versioning required**  | Must be enabled on both source and destination for replication to track changes. |
| **Snapshots not supported**   | Blob snapshots (point-in-time backups) are *not replicated*.                     |
| **Supported tiers**           | Works with **Hot**, **Cool**, and **Cold** tiers (Archive tier not supported).   |
| **Different tiers allowed**   | Source and destination can use different access tiers.                           |
| **Same or different regions** | Can replicate within region or across regions (depending on your needs).         |
| **One-way replication**       | Replication is **one-directional** ‚Äî from source ‚Üí destination only.             |
| **Asynchronous**              | Replication happens **in the background**, not instantly.                        |
| **Metadata replication**      | System properties and tags are also replicated.                                  |


A blob can be any type of data and any size file. Azure Storage offers three types of blobs: block blob, page blob, and append blob.
  Block blobs. A block blob consists of blocks of data that are assembled to make a blob. Most Blob Storage scenarios use block blobs. Block blobs are ideal for storing text and binary data in the cloud, like files, images, and videos. The block blob type is the default type for a new blob. When you're creating a new blob, if you don't choose a specific type, the new blob is created as a block blob.
  Append blobs. An append blob is similar to a block blob because the append blob also consists of blocks of data. The blocks of data in an append blob are optimized for append operations. Append blobs are useful for logging scenarios, where the amount of data can increase as the logging operation continues.
  Page blobs. A page blob can be up to 8 TB in size. Page blobs are more efficient for frequent read/write operations. Azure Virtual Machines uses page blobs for operating system disks and data disks.
##After you create a blob, you can't change its type.

| Feature                  | **Block Blob**                 | **Append Blob**      | **Page Blob**               |
| ------------------------ | ------------------------------ | -------------------- | --------------------------- |
| **Structure**            | Blocks (committed as a whole)  | Blocks (append-only) | Pages (512 bytes)           |
| **Update Type**          | Replace entire blob            | Append only          | Random read/write           |
| **Max Size**             | 190.7 TiB                      | 195 GB               | 8 TiB                       |
| **Performance Type**     | General purpose                | Sequential append    | High-performance random I/O |
| **Used By**              | Files, backups, static content | Logs, audit data     | Virtual Machines            |
| **Typical Storage Tier** | Hot/Cool/Cold/Archive          | Hot/Cool             | Premium                     |
| **Versioning Supported** | ‚úÖ                              | ‚úÖ                    | ‚úÖ                           |
| **Example**              | Uploading a video              | Logging web requests | VM OS disk (VHD)            |

üîπ 1. Block Blob
üß† Concept:
The most common blob type.
Files are divided into blocks, each with a unique ID.
After uploading all blocks, you commit them to create or update a blob.

üîπ 2. Append Blob
üß† Concept:
Optimized for append-only operations ‚Äî you can only add data to the end.
Perfect for data that grows continuously, like logs or telemetry data.
Existing data cannot be modified or deleted.

üîπ 3. Page Blob
üß† Concept:
Made up of 512-byte pages that can be read or written individually.
Supports random read/write access.
Primarily used for Azure Virtual Machine disks (.vhd files).

For larger numbers of files, it's best to use a tool. Review the following options and consider which tools would suit your configuration needs.
Azure Storage Explorer. Upload, download, and manage blobs, files, queues, and tables, as well as Azure Data Lake Storage entities and managed disks. 
You can also view, edit, and manage resources, preview data, and configure storage permissions and access controls.
AzCopy. An easy-to-use command-line tool for Windows and Linux. You can copy data to and from Blob Storage, across containers, and across storage accounts.
Azure Data Box Disk. A service for transferring on-premises data to Blob Storage when large datasets or network constraints make uploading data over the wire unrealistic. 
You can use Azure Data Box Disk to request solid-state disks (SSDs) from Microsoft. You can copy your data to those disks and ship them back to Microsoft to be uploaded into Blob Storage.

Changes to the storage tier. If you change the account storage tier from Cool to Hot, you incur a charge equal to reading all the data existing in the storage account. 
Changing the account storage tier from Hot to Cool incurs a charge equal to writing all the data into the Cool tier (GPv2 accounts only).












